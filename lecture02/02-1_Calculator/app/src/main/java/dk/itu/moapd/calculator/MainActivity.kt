/*
 * MIT License
 *
 * Copyright (c) 2024 Fabricio Batista Narcizo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package dk.itu.moapd.calculator

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.HapticFeedbackConstants
import dk.itu.moapd.calculator.databinding.ActivityMainBinding
import dk.itu.moapd.calculator.databinding.ButtonsLayoutBinding
import dk.itu.moapd.calculator.databinding.ResultLayoutBinding
import org.mozilla.javascript.Context

/**
 * An activity class with methods to manage the main activity of Calculator application.
 */
class MainActivity : AppCompatActivity() {

    /**
     * View binding is a feature that allows you to more easily write code that interacts with
     * views. Once view binding is enabled in a module, it generates a binding class for each XML
     * layout file present in that module. An instance of a binding class contains direct references
     * to all views that have an ID in the corresponding layout.
     */
    private lateinit var mainBinding: ActivityMainBinding
    private lateinit var buttonsBinding: ButtonsLayoutBinding
    private lateinit var resultBinding: ResultLayoutBinding

    /**
     * A `String` to persist the latest mathematical symbol pressed by the user.
     */
    private var currentSymbol: String = ""

    /**
     * Called when the activity is starting. This is where most initialization should go: calling
     * `setContentView(int)` to inflate the activity's UI, using `findViewById()` to
     * programmatically interact with widgets in the UI, calling
     * `managedQuery(android.net.Uri, String[], String, String[], String)` to retrieve cursors for
     * data being displayed, etc.
     *
     * You can call `finish()` from within this function, in which case `onDestroy()` will be
     * immediately called after `onCreate()` without any of the rest of the activity lifecycle
     * (`onStart()`, `onResume()`, onPause()`, etc) executing.
     *
     * <em>Derived classes must call through to the super class's implementation of this method. If
     * they do not, an exception will be thrown.</em>
     *
     * @param savedInstanceState If the activity is being re-initialized after previously being shut
     * down then this Bundle contains the data it most recently supplied in `onSaveInstanceState()`.
     * <b><i>Note: Otherwise it is null.</i></b>
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        initializeViews()
        setupButtonListeners()
    }

    /**
     * Initializes the views using Jetpack view binding.
     *
     * This method inflates the layout using the corresponding binding classes generated by Jetpack
     * view binding. It binds the layout components to their respective properties in the activity,
     * allowing for type-safe access to views without relying on Kotlin synthetics.
     */
    private fun initializeViews() {

        // Migrate from Kotlin synthetics to Jetpack view binding.
        // https://developer.android.com/topic/libraries/view-binding/migration
        mainBinding = ActivityMainBinding.inflate(layoutInflater)
        buttonsBinding = ButtonsLayoutBinding.bind(mainBinding.root)
        resultBinding = ResultLayoutBinding.bind(mainBinding.root)

        // Inflate the user interface into the current activity.
        setContentView(mainBinding.root)
    }

    /**
     * Sets up listeners for buttons to handle user input.
     *
     * This method sets up listeners for number buttons and symbol buttons using Jetpack view
     * binding. It assigns each button a click listener that triggers specific actions when the
     * button is clicked, such as handling number input or symbol input.
     *
     * @see [Haptic Feedback](https://developer.android.com/reference/android/view/HapticFeedbackConstants)
     */
    private fun setupButtonListeners() {
        with(buttonsBinding) {

            // Set up listeners for number buttons.
            listOf(buttonZero, buttonOne, buttonTwo, buttonThree, buttonFour,
                buttonFive, buttonSix, buttonSeven, buttonEight, buttonNine)
                .forEachIndexed { index, button ->
                    button.setOnClickListener {
                        it.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                        handleNumberButtonClick(index)
                    }
                }

            // Set up listener for symbol buttons.
            listOf(buttonPlusMinus, buttonClear, buttonPercentage, buttonDivide,
                buttonMultiple, buttonMinus, buttonAdd, buttonDot)
                .forEach { button ->
                    button.setOnClickListener {
                        it.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                        handleSymbolButtonClick(button.text.toString())
                    }
                }

            // Set up listener for equals button.
            buttonEquals.setOnClickListener {
                it.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                calculateEquation()
            }
        }
    }

    /**
     * Handles the click event of a number button.
     *
     * This method updates the input text field with the pressed number. If the current symbol is
     * empty, indicating that no mathematical operation has been selected yet, it clears the output
     * text field. The input value is checked for length, and if it exceeds 9 characters, it remains
     * unchanged. Otherwise, the input value is updated with the new number.
     *
     * @param number The number pressed by the user.
     */
    private fun handleNumberButtonClick(number: Int) {
        with(resultBinding) {
            if (currentSymbol.isEmpty()) output.text = ""
            input.text = getCurrentValue().let { currentValue ->
                if (currentValue.length > 9) currentValue
                else updateCurrentValue(currentValue, number)
            }
        }
    }

    /**
     * Handles button clicks for mathematical symbols in the calculator.
     *
     * @param symbol The symbol representing the button clicked.
     */
    private fun handleSymbolButtonClick(symbol: String) {
        when (symbol) {
            "AC" -> resetCalculatorState()
            "+/-" -> updateInputWithPlusMinus()
            "%" -> updateInputWithPercentage()
            "." -> addDecimalPointToInput()
            else -> handleMathSymbols(symbol)
        }
    }

    /**
     * Retrieves the current value from the input field.
     *
     * This method retrieves the text from the input field of the calculator interface using Jetpack
     * view binding. If the input is empty, it returns "0" as the default value.
     *
     * @return The current value displayed in the input field as a `String`.
     */
    private fun getCurrentValue(): String {
        return resultBinding.input.text.toString().let {
            it.ifEmpty { "0" }
        }
    }

    /**
     * Updates the current value with the given number and returns the updated value.
     *
     * If the current value is equal to zero and does not contain a decimal point, the function
     * returns the string representation of the given number. Otherwise, it concatenates the number
     * to the current value and returns the result.
     *
     * @param currentValue The current value as a string.
     * @param number The number to be appended to the current value.
     *
     * @return The updated value after appending the number.
     */
    private fun updateCurrentValue(currentValue: String, number: Int): String {
        return if (currentValue.toFloatOrNull() == 0f && '.' !in currentValue) {
            number.toString()
        } else {
            "$currentValue$number"
        }
    }

    /**
     * Resets the state of the calculator by clearing the input and output fields, and resetting the
     * current symbol.
     */
    private fun resetCalculatorState() {
        resultBinding.apply {
            input.text = "0"
            output.text = ""
        }
        currentSymbol = ""
    }

    /**
     * Updates the input field with the current value toggled between positive and negative.
     */
    private fun updateInputWithPlusMinus() {
        resultBinding.input.text = getCurrentValue().let { currentValue ->
            if (currentValue.startsWith("-")) {
                currentValue.substring(1)
            } else {
                "-$currentValue"
            }
        }
    }

    /**
     * Updates the input field with the current value divided by 100 (converted to a percentage). If
     * the current value cannot be converted to a float, "0" is set as the input value.
     */
    private fun updateInputWithPercentage() {
        val value = getCurrentValue().toFloatOrNull()?.div(100)?.toString() ?: "0"
        resultBinding.input.text = value
    }

    /**
     * Adds a decimal point to the input field if it doesn't already contain one.
     */
    private fun addDecimalPointToInput() {
        val currentValue = getCurrentValue()
        resultBinding.input.text = if (currentValue.contains(".")) currentValue else "$currentValue."
    }

    /**
     * Handles mathematical symbols other than AC, +/-, %, and ..
     * If the input is empty, sets the current symbol and returns.
     * Otherwise, updates the current equation, sets the output text, sets the current symbol, and clears the input text.
     * @param symbol The mathematical symbol to handle.
     */
    private fun handleMathSymbols(symbol: String) {

        // If the input is empty, set the current symbol and return.
        if (resultBinding.input.text.isEmpty()) {
            currentSymbol = symbol
            return
        }

        // Update the current equation with the current value and symbol.
        val currentEquation = updateCurrentEquation(getCurrentValue())
        resultBinding.apply {
            output.text = currentEquation
            currentSymbol = symbol
            input.text = ""
        }
    }

    /**
     * Updates the current equation with the provided value. If the value starts with '-', toggles
     * the sign based on the current symbol. Appends the current symbol and the updated value to the
     * existing output text.
     *
     * @param currentValue The value to update the current equation with.
     *
     * @return The updated current equation.
     */
    private fun updateCurrentEquation(currentValue: String): String {
        val sign = currentValue.firstOrNull()
        val updatedCurrentValue = if (sign == '-' && resultBinding.output.text.isNotBlank()) {
            when (currentSymbol) {
                "-" -> {
                    currentSymbol = "+"
                    currentValue.substring(1)
                }
                "+" -> {
                    currentSymbol = "-"
                    currentValue.substring(1)
                }
                else -> {
                    getString(R.string.text_parenthesis, currentValue)
                }
            }
        } else {
            currentValue
        }
        return resultBinding.output.text.toString() + currentSymbol + updatedCurrentValue
    }

    /**
     * Calculates the result of the current equation using JavaScript evaluation.
     * Replaces 'X' with '*' in the equation before evaluation.
     * If an error occurs during evaluation, sets the result to "Error".
     * If the result is a whole number, removes the decimal part.
     * Updates the output text with the result and resets the input text to "0".
     */
    private fun calculateEquation() {
        resultBinding.apply {
            if (currentSymbol.isEmpty() || output.text == "Error") return

            var result = try {
                val currentEquation = updateCurrentEquation(getCurrentValue()).replace("X", "*")
                val rhino = Context.enter().apply { optimizationLevel = -1 }
                val scope = rhino.initStandardObjects()
                rhino.evaluateString(scope, currentEquation, "JavaScript", 1, null).toString()
            } catch (ex: Exception) {
                "Error"
            }

            result = result.split(".").let { if (it.size > 1 && it[1] == "0") it[0] else result }

            output.text = result
            input.text = ""
        }
    }

}
